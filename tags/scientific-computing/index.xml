<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Scientific Computing on Wu Sun, Ph.D.</title>
    <link>https://wusun.name/tags/scientific-computing/</link>
    <description>Recent content in Scientific Computing on Wu Sun, Ph.D.</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 22 Dec 2021 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://wusun.name/tags/scientific-computing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Is there a performance difference between a macro and a global constant?</title>
      <link>https://wusun.name/blog/2018-05-24-julia-macro-vs-globalconst/</link>
      <pubDate>Thu, 24 May 2018 00:00:00 +0000</pubDate>
      <guid>https://wusun.name/blog/2018-05-24-julia-macro-vs-globalconst/</guid>
      <description>Disclaimer on 2018-11-30: These tests were performed under Julia v0.6. Due to the incompatible syntax changes brought by Julia v0.7 and v1.0 and improved compiler optimization, they may not run or the emitted low-level code may not be the same.&#xA;The use of the global variable is discouraged in Julia for performance reasons (see the Julia documentation). But what about global constants? I&amp;rsquo;m quite new to the Julia language, but I bet that it would not be difficult for the compiler to identify a const and optimize over it.</description>
    </item>
    <item>
      <title>A simple fix to a common issue with Anaconda libgfortran on macOS</title>
      <link>https://wusun.name/blog/2018-04-27-conda-libgfortran-issue/</link>
      <pubDate>Fri, 27 Apr 2018 00:00:00 +0000</pubDate>
      <guid>https://wusun.name/blog/2018-04-27-conda-libgfortran-issue/</guid>
      <description>To compile some Fortran code that used features newer than Fortran 95, I switched the default gfortran from the conda one (version 4.8) to the latest GCC one (version 7.3). After that, I found that I could no longer execute some previously compiled Fortran programs and I also ran into troubles with some Anaconda Python packages. (Maybe it was my fault not to statically link them.) I got the same error for all of them:</description>
    </item>
    <item>
      <title>Some common pitfalls in writing Fortran functions</title>
      <link>https://wusun.name/blog/2018-04-25-fortran-functions/</link>
      <pubDate>Wed, 25 Apr 2018 00:00:00 +0000</pubDate>
      <guid>https://wusun.name/blog/2018-04-25-fortran-functions/</guid>
      <description>Recently, I have been trying to port or interface some Fortran code for a project in Python. It was quite an uphill struggle for me. I thought I knew how to write subroutines in Fortran 90, but when I decided to write pure functions in the latest Fortran style, which was Fortran 2008, it did not go as well as I expected. The compiler yelled at me a screenful of errors.</description>
    </item>
    <item>
      <title>Why Python&#39;s ZeroDivisionError for floating-point type is a bad and unnecessary feature</title>
      <link>https://wusun.name/blog/2017-12-18-python-zerodiv/</link>
      <pubDate>Mon, 18 Dec 2017 00:00:00 +0000</pubDate>
      <guid>https://wusun.name/blog/2017-12-18-python-zerodiv/</guid>
      <description>In Python 2.7 and 3.6, dividing a floating-point number by zero results in a ZeroDivisionError:&#xA;&amp;gt;&amp;gt;&amp;gt; 1. / 0. Traceback (most recent call last): File &amp;#34;&amp;lt;stdin&amp;gt;&amp;#34;, line 1, in &amp;lt;module&amp;gt; ZeroDivisionError: float division by zero This is not consistent with mathematics, given that $1 / 0 = \infty$. Wouldn&amp;rsquo;t it be better to just return inf? In fact, the exception &amp;ldquo;division by zero&amp;rdquo; has been stipulated to return infinities in the IEEE 754 standard for floating-point arithmetic [1]:</description>
    </item>
  </channel>
</rss>
